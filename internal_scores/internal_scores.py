"""
This api exploit concerns the json 'score sheet' used internally by Eduka
The score sheet stores students answers to questions in real time,
it also shows how many points for each question the student has received.

The score sheet is auto generated and can be found here:
https://klase.eduka.lt/api/student/quiz-templates/data/{test_ID}/sprendimas

Keep in mind each quiz (or test) has an unique id that has to be extracted,
it can be found in URL when you open the quiz in browser. For example:
https://klase.eduka.lt/student/lesson-material/show/27980981/3629303/1
                                                    ▲▲▲▲▲▲▲▲
                                                    test_ID
this test_ID is important, as it is required for all of the api calls.

This score sheet can't be fully trusted, for example, it isn't fully
populated until the student has loaded all of the questions, meaning
that it can show that a quiz has only 1 or even 0 questions if none
of them have been loaded in before. The score sheet is also weirdly
obscured, with random double backslashes, and unnesacary quotation marks.
It needs to be parsed in order to be usable. After parsing the data of interest
can be found in dict['workingState']['score'] dictionary.

Finally the questions in score sheet aren't provided in order, to fix this
a separate api call has to be made to
https://klase.eduka.lt/api/student/quiz-templates/task-package-content/{test_ID}
to get a XML file containing ordered question ids.

In short, the usage of this class might look like this:

1. Initiate Handler() with login data
2. GET the obscured score_sheet using
    Handler.get_internal_scores_obscured()
3. Pass the obscured string into json parser using
    Handler.parse_internal_json()
4. Get the correct question ordering using
    Handler.get_internal_scores_order()
5. The parsed json can be sorted using the correct question ordering and used
   needed.


Dependencies not in standard lib: requests
"""
import json
import xml.etree.ElementTree as ET

import requests


class Handler():
    def __init__(self, username: str, password: str) -> None:
        """
        Creates the initial session, set ups handler
        
        :param str username: Eduka username
        :param str password: Eduka password
        """
        self.login_data = {
            'username': username,
            'password': password
        }

        self.session = requests.Session()
        self._login_session()

    def _login_session(self) -> None:
        """
        Logs in with provided login_data
        
        :raises HTTPError: if the login is unsuccessful
        """
        login_status = self.session.post("https://klase.eduka.lt/api/anonymously/login", data=self.login_data)
        
        login_status.raise_for_status()
                
    def change_login_data(self, username: str, password: str) -> None:
        """
        Changes `self.login_data` after the `Handler` has been
        created
        
        :param str username: Eduka username
        :param str password: Eduka password
        """
        self.login_data = {
            'username': username,
            'password': password
        }
        
        # recreate session, login to get auth + cookies
        self.session = requests.Session()
        self._login_session()
        
    def get_internal_scores_obscured(self, test_ID: int) -> str:
        """
        Returns json answer sheet that is used internally
        to score the quiz.
        
        The return of this function can't
        be trusted, as the answer sheet is obscured json, and the
        tasks are not provided in order. For further use this
        data should be passed into `Handler.parse_internal_json`
        and sorted using `Handler.get_internal_scores_order()`.
        
        :param int test_id: Test id
        
        :returns str obscured_string: Obscured answer sheet data string
        """
    
        answers_request = self.session.get(f"https://klase.eduka.lt/api/student/quiz-templates/data/{test_ID}/sprendimas")
        
        answers_request.raise_for_status()
        
        return answers_request.text
    
    def parse_internal_json(self, obscured_string: str) -> dict:
        """
        Returns `json` dict of internal scores sheet.
        
        Parses out the internal json answers sheet, removes
        double backslashes `\\\\`, also removes unnecessary
        quatation marks `"` around `{ }` and `[ ]` tags.
        
        !! Scores in this dictionary are still unordered 
        `Handler.get_internal_scores_order()` should be used
        for ordering this dictionary data.
        
        :param str obscured_string: obscured json string retrieved using `Handler.get_internal_scores_obscured()`
        :returns dict clean_json: Clean and ready `json` object
        """
        obscured_string = obscured_string.replace("\\", "")
        
        clean_string = ""
        
        for index, char in enumerate(obscured_string):
            if char == "\"":
                if obscured_string[index + 1] in ("{", "["):
                    continue
                elif obscured_string[index - 1] in ("}", "]"):
                    continue
                else:
                    clean_string = clean_string + char
            else:
                clean_string = clean_string + char
        
        return json.loads(clean_string)
    
    def get_internal_scores_order(self, test_ID: int) -> list:
        """
        Returns the quiz questions ids, correctly ordered in a list
        
        Gets internal XML file containing a list of `<page>` tags.
        Each of these tags is a quiz question. They are presented
        in the correct order. Using ElmentTree extracts these tags
        and creates an ordered list of quiz question ids
        
        
        :param int test_id: Test id
        
        :returns list question_ids: Ordered quiz question ids
        """
    
        xml_request = self.session.get(f"https://klase.eduka.lt/api/student/quiz-templates/task-package-content/{test_ID}")
        
        xml_request.raise_for_status()
        
        question_ids = []
        parent_pages_tag = ET.fromstring(xml_request.text).find("pages")
        for element in parent_pages_tag:
            if element.tag == "page":
                question_ids.append(element.attrib['id'])
        
        return question_ids
